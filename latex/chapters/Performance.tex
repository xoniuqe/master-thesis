\chapter{Analyse und Auswertung}\label{analysis}


\section{Testsystem}

Die Performanztests wurden auf einem Vierkernprozessor Intel i5-4590 mit 8GB Arbeitsspeicher durchgeführt.


\section{Analyse mit Valgrind}

In diesem Abschnit wird auf die Analyse des Projektes mit Valgrind eingegangen. Zunächst werden Valgrind und die daraus benutzten Tools vorgestellt und dann werden einige Ergebnisse präsentiert.
\subsection{Valgrind}

Valgrind ist einerseits ein Framework zum Erzeugen von dynamsichen Analyse-Werkzeugen und andereseits eine Sammlung ebensolcher Werkzeuge (siehe \cite{10.1145/1250734.1250746}). 
Valgrind ist offene Software und wird unter der GNU GPL-2 Lizenz veröffentlicht\footnote{\url{https://valgrind.org/}}.
Die Sammlung bietet acht Werkzeuge\footnote{vgl. \url{https://valgrind.org/info/tools.html}} an von denen eines noch den Status eines experimentellen Werkzeugs hat:
\begin{itemize}
  \item Memcheck, ein Werkzeug zum Analysieren von Speicherlecks
  \item Cachegrind, ein Cache und Branch-prediction Profiler
  \item Callgrind, ein Profiler der einen Aufrufgraphen erzeugt
  \item Helgrind und DRD, Werkzeuge um Threading-Fehler zu erkennen
  \item Massif und DHAT, Heapprofiler für Analysen hinsichtlich speichereffizienter Programme 
  \item BBV, ein Werkzeug für die Forschung im Bereich der Rechnerarchitektur
\end{itemize}

In dieser Arbeit wurden die Werkzeuge Memcheck, Cachegrind und Callgrind verwendet. Die Ergebnisse der Werkzeuge DRD und Helgrind waren unbrauchbar, da diese nicht mit oneTBB kompatibel waren.

\subsubsection{Cachegrind und Callgrind}

Cachegrind und Callgrind, entwickelt von \citeauthor{Weidendorfer2004ATS} \cite{Weidendorfer2004ATS}, sind sogenannte Cacheprofiler. 
Diese Werkzeuge werden verwendet um die Programmstellen mit der größten Laufzeit festzustellen und verschiedene Umstellungen im Programmcode vergleichen zu können.

Cachegrind simuliert wie das zu testende Programm mit der Cache-Hierarchie und dem Branch-Predictor einer virtuellen Maschine interagiert. Die dabei simulierte Maschine ist orientiert an der Architektur moderner Maschinen.
Dabei werden verschiedene Caches simuliert und die Zugriffe darauf hinsichtlich von Misses ausgewertet. In Abbildung \ref{callgrind} ist ein Beispielaufruf zu sehen.
 

\begin{figure}
  \includegraphics{images/callgrind.png}
  \caption{Beispielaufruf von Callgrind}\label{callgrind}
\end{figure}
%\subsubsection{Memcheck}

%Gehört eigentlihc nciht wirklcih hier her
%Screenshot plus was macht das Tool. Wir haben das genutzt um sicherzustellen, dass es keine Memoryleaks gibt.

\subsubsection{Auswerten von callgrind-Ergebnissen}


Mithilfe der Anwendung QCachegrind können die Ergebnisse von Valgrinds cachegrind/callgrind grafisch ausgewertet werden. QCachegrind ist ein Windowsbuild der Opensource Anwendung KCacheGrind.
KCachegrind ist Teil der Werkzeuge aus der Arbeit \cite{Weidendorfer2004ATS}.

\begin{figure}
  \includegraphics[width=\textwidth]{images/qcachegrind.png}
  \caption{Übersicht von QCachegrind}\label{qcachegrind}
\end{figure}

In Abbildung \ref{qcachegrind} ist eine Übersicht einer Auswertung mit QCachegrind zu sehen. In diesem Beispiel wurde mithilfe des Werkzeugs \texttt{callgrind} eine Aufzeichnung des zweidimensionalen Falls 
mit verschiedenen Wellenzahlen und jeweils 40 Stichproben von Beobachtungspunkt und Richtungsektoren für ein festes Dreieck berechnet.
Abbildung \ref{qcachegrind_result} stellt einen Ausschnitt des Aufrufgraphen vergrößert dar. In diesem lässt sich an Pfeilen ablesen wie oft welcher Programmteil aufgerufen wird und mithilfe einer prozentualen Angabe einsehen wie viel der Laufzeit in diesem Teil verbraucht wird.

\begin{figure}
  \includegraphics[width=\textwidth]{images/qcachegrind_callgraph.png}
  \caption{Aufrufgraph aus QCachegrind}\label{qcachegrind_result}
\end{figure}

Aus diesen und weiteren Auswertungen werden die meistaufgerufene Funktionen und der Hotpath ersichtlich.

\section{Ergebnisse der Optimierungsmaßnahmen}

In diesem Abschnitt wird auf einige Ergebnisse der manuellen Performanz-Messungen eingegangen.

\subsection{Hotpath}

Der häufigste Fall der Anwendung ist das Berechnen des Integrals in Situationen, in denen keine Singularität auftritt. 
Dementsprechend werden diese in den implementierten Funktionen als der Regelfall betrachtet.
Durch das vorziehen der Codestellen, die diese Szenarien abhandeln werden beispielsweise die benötigten Sprunganweisungen geringer gehalten.



\subsection{Meistaufgerufene Funktion}

Die Funktion mit der größten Laufzeit ist das \textit{Steepest-descent}-Verfahren.
Diese Funktion ist über mehrere Iterationen optimiert worden, bis sie die im Kapitel \ref{impl} dargestellte Form erreichte.
In früheren Versionen war dieses Verfahren in einer eigenen C++-Klasse implementiert, allerdings haben die Auswertungen gezeigt, dass ein
direkter Aufruf der Gauss-Laguerre-Quadratur einen Laufzeitgewinn von fast 50 Prozent erzielen lies.


\section{Auswertung der Laufzeitmessugen}

Die folgenen Laufzeitvergleiche wurden aus einer Matlab-Umgebung heraus ausgeführt, d.h. es werden die ursprüngliche Implementierung sowie das Matlab-Modul der C++-Implementierung verglichen.


\subsection{Iteration über Wellenzahl}


In diesem Test wird die Laufzeit hinsichtlich veränderter Wellenzahl \linebreak $k \in \{ 100, 500, 1000, 3000, 5000 \}$ gemessen.
Für jedes $k$ werden 50 zufällige Richtungsvektoren $r$ berechnet mit 600 Gauss-Laguerre-Knoten berechnet.

\begin{equation}
  A = \begin{pmatrix}
      0 & 0 \\
      1 & 0 \\
      0 & 1 \\
  \end{pmatrix}, b = \begin{pmatrix}
      0 \\ 0\\ 0
  \end{pmatrix},
\end{equation}

\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
          width=\textwidth,
                  %width=3.358in,
        %height=2.309in,
        %at={(0.563in,0.312in)},
        scale only axis,
        yticklabel style={
          /pgf/number format/fixed,
          /pgf/number format/precision=2,
          /pgf/number format/fixed zerofill
        },
        extra y ticks={-0.05, 0.05},
        scaled y ticks=false,
        xlabel=Wellenzahl k,
        ylabel=\text{CPU-Laufzeit [s]},
        %xmin=0,
       % xmax=6000,
        %ymin=0,
        %ymax=0.5,
        axis background/.style={fill=white},
        legend style={legend cell align=left, align=left, draw=white!15!black}
        ]
        \addplot+[
      green, mark options={green, scale=0.75},
      smooth, 
      error bars/.cd, 
        y fixed,
        y dir=both, 
        y explicit ] table [color=green, mark=o, mark options={solid, green} x=k, y=t,y error=std, col sep=comma] { 
            k, t, std 
            100, 0.0546875000000000, 0.0377819439281490
            500, 0.0421875000000000, 0.0304832595619367
            1000, 0.0396875000000000, 0.0304767208961468
            3000, 0.0393750000000000, 0.0399597214296433
            5000, 0.0340625000000000, 0.0374428241844571         
          };
          \addplot+[
            red, mark options={red, scale=0.75},
            smooth, 
            error bars/.cd, 
              y fixed,
              y dir=both, 
              y explicit ] table [color=red, mark=o, mark options={solid, red} x=k, y=t,y error=std, col sep=comma] { 
                  k, t, std 
                  100, 0.120625000000000, 0.0825011595465820
                  500, 0.0928125000000000, 0.0439012055439740
                  1000, 0.0959375000000000, 0.0326549607327770
                  3000, 0.120625000000000, 0.164181352722021
                  5000, 0.0943750000000000, 0.0724645849462240          
                };
        %\addplot [color=red, draw=none, mark=o, mark options={solid, mycolor1}]
        %  table[row sep=crcr] file {..\data\performance_matlab.csv};
        \addlegendentry{C++ Implementierung}
        \addlegendentry{MatLab Implementierung}

        \end{axis}
    \end{tikzpicture}%
    \captionof{figure}{Laufzeitvergleich über verschiedene Wellenzahlen $k$, die Fehlerbalken zeigen die Standardabweichung}
\end{center}


\subsection{Laufzeitvergleich bei steigender Auflösung}


In diesem Test wird die Laufzeit hinsichtlich veränderter Auflösung $res \in \{ 0.1, 0.01, 0.001, 0.0001 \}$ gemessen.
Für jedes $k$ werden 50 zufällige Richtungsvektoren $r$ berechnet mit 600 Gauss-Laguerre-Knoten berechnet.

\begin{equation}
  A = \begin{pmatrix}
      0 & 0 \\
      1 & 0 \\
      0 & 1 \\
  \end{pmatrix}, b = \begin{pmatrix}
      0 \\ 0\\ 0
  \end{pmatrix},
\end{equation}
    
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
        %width=3.358in,
        %height=2.309in,
        %at={(0.563in,0.312in)},
        scale only axis,
        xmode=log,
        ymode=log,
        ymax=1000,
        width=\textwidth,
        %log ticks with fixed point,
        x dir=reverse,
        ylabel=\text{CPU-Laufzeit [s] (log)},
        xlabel=Layer-Auflösung (log),
        % for log axes, x filter operates on LOGS.
        % and log(x * 1000) = log(x) + log(1000):
        %x filter/.code=\pgfmathparse{#1 + 6.90775527898214},
        axis background/.style={fill=white},
        legend style={legend cell align=left, align=left, draw=white!15!black}
        ]
        \addplot+[
      green, mark options={green, scale=0.75},
      smooth, 
      error bars/.cd, 
        y fixed,
        y dir=both, 
        y explicit ] table [color=green, mark=o, mark options={solid, green} x=res, y=t,y error=std, col sep=comma] { 
            res, t, std
            0.1000,    0.0563,    0.0461
            0.0100,    0.3469,    0.0645
            0.0010,   3.8547,    1.6996
            0.0001,  38.9781,   15.6876
          };
          \addplot+[
            red, mark options={red, scale=0.75},
            smooth, 
            error bars/.cd, 
              y fixed,
              y dir=both, 
              y explicit ] table [color=red, mark=o, mark options={solid, red} x=res, y=t,y error=std, col sep=comma] { 
                  res, t, std
                  0.1000,    0.1375,    0.0799
                  0.0100,    0.8688,    0.0834
                  0.0010,    9.5406,    4.2787
                  0.0001,   86.2375,   27.7633
                };
        %\addplot [color=red, draw=none, mark=o, mark options={solid, mycolor1}]
        %  table[row sep=crcr] file {..\data\performance_matlab.csv};
        \addlegendentry{C++ Implementierung}
        \addlegendentry{MatLab Implementierung}
        \end{axis}
    \end{tikzpicture}%
    \captionof{figure}{Laufzeitvergleich über verschiedene Auflösungen, logarithmische Skalen, die Fehlerbalken zeigen die Standardabweichung}
\end{center}


\section{Vergleiche der Genauigkeit}

In diesem Abschnitt werden die numerischen Experimente aus Kapitel 6 von \cite{gasperini:hal-03209144} mit der in dieser Arbeit entwickelten C++-Implementierung durchgeführt.
Die Konfiguration ist wie folgt:

\begin{equation}
  A = \begin{pmatrix}
      0 & 0 \\
      2 & 0 \\
      0 & 2 \\
  \end{pmatrix}, b = \begin{pmatrix}
      0 \\ -0.5\\ 0
  \end{pmatrix},
  r = d \begin{pmatrix}
      cos(\alpha) \\ sin(\alpha) \\ 0
  \end{pmatrix} + \begin{pmatrix}
    0 \\ sin(\alpha) \\ 0
\end{pmatrix}, \theta \begin{pmatrix}
   1 \\ 0 \\ 0
\end{pmatrix}
\end{equation}\label{num_config}


\subsection{Eindimensionaler Fall}

Die Tests im eindimensionalen Fall werden wie in Kapitel 6.1 von \cite{gasperini:hal-03209144} mit 160 Gauss-Laguerre-Knoten durchgeführt.
Für die Konfiguration (siehe \ref{num_config}) und festgewählte $\alpha = 0$ und $d=0.6$ die relative Genauigkeit verglichen.
Diese Konfiguration enthält einen \textit{Splitting-point} in der Mitte des zu berechnenden Intervalls. (vgl Kapitel 6.1, Tabelle 3 in \cite{gasperini:hal-03209144})
In Tabelle \ref{accu} ist die Auswertung dieses Vergleichs zu sehen.

\begin{table}[ht]
  \centering
  \begin{tblr}{hlines,
      vlines,
      colspec={M{1.5cm}M{5cm}M{5cm}M{3cm}}}
      $k$ & C++-Implementierung & Matlab \textit{integral}-Funktion & Relativer Fehler \\
      100 &  $-0.07799217 + 0.13435696i$ &  $-0.07799217 + 0.13435696i$ & $1.12\times10^{-15}$ \\
      500 &   $0.04810768 + 0.05294844i$	&  $0.04810768 + 0.05294844i$ & $2.12\times10^{-14}$ \\
      1000 & $-0.03836233 + 0.03374236i$ &  $-0.03836224 + 0.03374733i$	& $9.71\times10^{-5}$ \\
      3000 & $-0.02377403 + 0.01807411i$	& $-0.02377404 + 0.01807412i$ & $5.11\times10^{-7}$ \\ 
      5000 & $-0.01930278 + 0.01243698i$	& $-0.01930278 + 0.01243698i$ & $1.31\times10^{-8}$ \\
  \end{tblr}
  \caption{Auswertung des Integrals $I(k,0,0,1)$ im Vergleich zu Matlab}\label{accu}
\end{table}

Im Vergleich des relativen Fehlers in diesem Versuch und Tabelle 3 aus \cite{gasperini:hal-03209144}
sind die relativen Fehler in ihrer Größenordnung gleichwertig. 
%In Tabelle \ref{accu_comp} wird der gleiche Versuch im Vergleich mit der 

%\begin{table}[ht]
%  \centering
%  \begin{tblr}{hlines,
%      vlines,
%      colspec={M{1.5cm}M{5cm}M{5cm}M{3cm}}}
%      $k$ & C++-Implementierung & Matlab \textit{Steepest-descent} & Relativer Fehler \\
%      100  & $-0.07799217 + 0.13435696i$ & $-0.07799217 + 0.13435696i$ & $1.44\times10^{-15}$ \\
%      500  & $ 0.04810768 + 0.05294844i$ & $ 0.04810768 + 0.05294844i$ & $1.06\times10^{-14}$ \\
%      1000 & $-0.03836233 + 0.03374236i$ & $-0.03836233 + 0.03374236i$ & $2.49\times10^{-15}$ \\
%      3000 & $-0.02377403 + 0.01807411i$ & $-0.02377403 + 0.01807411i$ & $1.04\times10^{-13}$ \\
%      5000 & $-0.01930278 + 0.01243698i$ & $-0.01930278 + 0.01243698i$ & $6.26\times10^{-14}$ \\    
%  \end{tblr}
%  \caption{Auswertung des Integrals $I(k,0,0,1)$ im Vergleich zur ursprünglichen Implementierung}\label{accu_comp}
%\end{table}



\subsection{Zweidimensionaler Fall}


Für den Test des zweidimensionalen Falls wird wieder auf festgewählte $\alpha = 0$ und $d=0.6$ zurückgegriffen.
Die Autoren schreiben in ihrer Auswertung, dass um die Berechnungen möglich sind mit geringeren Wellenzahlen $k$ getestet wird. (Siehe Kapitel 6.2 \cite{gasperini:hal-03209144})
Dies konnte in eigenen Tests nachvollzogen werden, da die Auswertungen von $k \in \{1000, 3000, 5000\}$ mehrere Stunden in Anspruch genommen haben.
Aufgrund eines Implementierungsfehler konnten diese Ergebnisse leider nicht verwertet werden, da dort die numerische Ungenauigkeit zu hoch war.

Zum  Vergleich wird die Funktion \textit{integral2} mit der Auflösung $res=0.0001$ über einzelne Schichten ausgewertet. Es wird die Wellenzahl $k=20$ verwendet.
Die Berechnung des Integrals mithilfe der Matlab Funktion wird in Abbildung \ref{matlab_integral} gezeigt. 
\begin{center}
  \begin{lstlisting}[language=MATLAB, breaklines]
    Im=0;
    count=0;
    for h = 0:res:1-res
          Im=Im+integral2(greenFun2D,0,1-count*res,count*res, (count+1)*res,'AbsTol',10^(-16),'RelTol',1e-8);
          count=count+1;      
    end
  \end{lstlisting}
  \captionof{figure}{Berechnung des 2D-Integrals in Matlab}\label{matlab_integral}
\end{center}

Die Ergebnisse dieses Vergleichs sind in Tabelle \ref{accu_2d} zu sehen.
\begin{table}[ht]
  \centering
  \begin{tblr}{hlines,
      vlines,
      colspec={M{1.5cm}M{5cm}M{5cm}M{3cm}}}
      $k$ & C++-Implementierung & Matlab \textit{integral2}-Funktion & Relativer Fehler \\
      5 & $-0.08447462 + 0.20608188i$ & $-0.0842793 + 0.20698190i$ & $4.1\times10^{-3}$ \\
      10 & $ 0.00682469 - 0.09068582i$ & $ 0.0066867 - 0.09105933i$ & $4.3\times10^{-3}$ \\
      20 & $ 0.02207955 - 0.02298169i$ & $ 0.0220181 - 0.02314369i$ & $5.4\times10^{-3}$ \\
  \end{tblr}
  \caption{Auswertung des Integrals $I_\Lambda(k)$ im Vergleich zu Matlab}\label{accu_2d}
\end{table}

%Im Vergleich zu der Auswertung in Tabelle 4 in \cite{gasperini:hal-03209144} fällt auf, dass die berechneten Integrale nicht übereinstimmen.
