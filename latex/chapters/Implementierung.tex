\chapter{Implementierung}

In diesem Kapitel wird dargelegt wie der Algorithmus implementiert wird. Zu Beginn wird erläutert warum welche Technologie zum Einsatz kommt und welche Alternativen es gibt.
\section{Verwendete Technologien}

Nur die Tools die für die Implementierung Nötig waren,
Profiler (VAlgrind) kommen ins Kapitel "Analyse und Bewertung"
Mit Stern markierte gerne etwas weiter ausführen
\begin{itemize}
    \item Armadillo
    \item GNU Scientific Library *
    \item Pybind (Eigen3) *
    \item OneTBB *
    \item Catch2
    \item Google Benchmarks
    \item CMake
    \item Visualstudio Profiler
    \item Valgrind*
\end{itemize}



Nicht genutzte Alternativen

Gründe noch aufführen
\begin{itemize}
    \item SIMD intrinsics * (mal sehen ob das sinnvoll ist)
    \item Boost numeric
    \item OpenCL
    \item OpenMP
    \item CUDA
\end{itemize}

\subsection{GNU Scientific Library}

Gerade bei der Frage nach dem Framework für Linalg und numerischer Integration lässt sich nicht abschätzen was die beste Lösung ist. Es gibt
so viele Frameworks und Bibliotheken, dass es nicht möglich ist alle gegeneinander Abzwuwägen.

Die Entshceidung GSL und Armadillo basier auf: Aramdillo ist einfach einzubinden und unkompliziert in der Anwendung.
GSL hat eine gute Perfomance. Der Verglecih lief mit Boost wobei einfache Tests zeigten das GSL schneller ist und mit weitaus weniger Aufwand in das Projekt integriert werden kann.
(Boost integration ist furchtbar!)

In dieser Arbeit wird das sogenannte \textit{CQUAD}-Integrationsverfahren verwendet.
Im Handbuch der GSL wird dieses Verfahren als
\begin{quotation}
    [...]CQUAD is a new doubly-adaptive general-purpose quadrature routine[...]
\end{quotation} \cite*[Kapitel 17.11]{book} beschrieben. Dieses Verfahren wird ausgewählt,da 
dies das selbe Verfahren ist welches in Matlab mit der Funktion \textit{integral2} verwendet wird.

Dieses Verfahren kann nicht direkt genutzt werden um die benötigten Integrationen aus \cite*{gasperini:hal-03209144} zu berechnen, da 
der \textit{CQUAD}-Algorithmus zum einen nur für eindimensionale Integrale und nur für den reellen Zahlenraum definiert ist.

Um dies zu ermöglichen sind zwei Anpassungen nötig:
\begin{enumerate}
    \item Das Verschachteln von zwei \textit{CQUAD} Aufrufen, und
    \item das auftrennen in zwei getrennte Aufrufe, jeweils für den Real- und Imaginär-teil der Integranden
\end{enumerate}

Die Implementierung für den Realteil ist in \ref{integration_2d} zu sehen.

\begin{figure}
    \lstinputlisting[language=C++,style=cpp]{gsl_integrator_2d.cpp}
    \caption{Implementierung des 1D-Falls (Singularität)}
    \label{integration_2d}
\end{figure}



\subsection{Armadillo}

Kurze Einführng (1 Seite max?)

\subsection{Intel Threading Building Blocks}

Darstellung der beschleunigten Stellen, bzw beispiele wie man damit was parallelsiert + kurze einführenng

\begin{itemize}
    \item Grobe EInleitugn was das ist und wie es klappt
    \item Grobes Beispiel anhand von \texttt{parallel\_for} und dann:
    \item \texttt{blocked\_range}
    \item \texttt{parallel\_reduce}
    \item \texttt{parallel\_deterministic\_reduce}
\end{itemize}

\subsection{Pybind}

Kurze erklärung wie es klappt und beispiel für einfaches Plugin

\subsection{Matlab Mex-Funktion}

Um eine C++-Funktion in Matlab zur Verfügung zu Stellen gibt es mehrere Ansätze.
Zum einen kann mithilfe von Matlab C++-Code kompiliert und anschließend genutzt werden. 
Die für den Endnutzer einfacherer Variante ist das Bereitstellen von sogenannten Mex-Funktionen.

Um eine Mex-Funktion zu implementieren müssen die Header-Dateien \texttt{mex.hpp} und \texttt{mexAdapter.hpp} inkludiert werden
und eine Funktion mit dem Namen \textit{MexFunction} implementiert werden. 

In Abbildung \ref{mexfunction} ist eine Beispiel-Implementierung zu sehen 
\begin{center}
    \lstinputlisting[language=C++,style=cpp]{mex_function.cpp}
    \captionof{figure}{Eine einfache Mex-Funktion ohne Logik}
    \label{mexfunction}
\end{center}

Nachdem diese kompiliert wurde lässt sie sich aus Matlab heraus aufrufen.

\section{Ausgewählte Codestellen}

\subsection{Gauss laguerre integration und Cauchy Integral Theoerem}

Implementiert das Gauss laguerre Qudarature mit der Pfad auswertung kombiniert.

Hier liegt noch der falsce code( für 1d aer wir wollen 2d zeigen)

\begin{figure}
    \lstinputlisting[language=C++,style=cpp]{gauss_laguerre.cpp}
    \caption{Implementierung der Gauss-Laguerre Quadratur}
\end{figure}
\subsection{1D Integration Berechnung der Singularität}

\begin{equation}
    I(k,y,a,b,) = I(k,y,a,a_1) + I(k,y,a_1, b_1) + I(k,y,b_1,b)
\end{equation}

Dabei wird $I(k,y,a_1, b_1)$ mithilfe klassischer Integrationsverfahren berechnet, dabei muss das folgene Integral berecnet werden:

\begin{equation}
    I(k,y,a,b) := \int_{a}^{b}  \frac{e^ikg(x)}{\sqrt{P(x)}} \,dx 
\end{equation}

\begin{figure}
    \lstinputlisting[language=C++,style=cpp,mathescape=true]{1d_integration_singularity.cpp}
    \caption{Implementierung des 1D-Falls (Singularität)}
\end{figure}


\subsection{2D Integration}

Warum konnte 1d Integration hier nicht direkt genutzt werden?
=> Indirektion durch das 1d Integral war relativ hoch, das teste ich aber besser noch mal


