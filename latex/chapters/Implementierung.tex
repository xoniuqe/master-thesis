\chapter{Implementierung}\label{impl}

In diesem Kapitel wird dargelegt, wie der Algorithmus implementiert wird. Zu Beginn wird erläutert welche Technologien zum Einsatz kommen und wie diese verwendet werden.
\section{Verwendete Technologien}

In diesem Abschnit werden die verwendeten Technologien vorgestellt. 


\subsection{GNU Scientific Library}

Die GNU Scientific Library (GSL) ist eine Sammlung von numerischen Funktionen\cite{gsl}. Die GSL wird unter der GNU General Public License veröffentlicht und ist in der Programmiersprache C geschrieben.

Die GSL bietet unter anderem Funktionen für \textit{Basic linear Algebrar Subprograms}(BLAS), verschiedene Interpolationsalgorihtmen, Monte-Carlo-Algorithmen, Implementierung für Fast Forier Tranformationen und die für diese 
Arbeit benötigten Algorithmen für die numerische Integration.
GSL bietet eine Reimplementierung des QUADPACK\cite{quadpack}, eine Fortran Bibiliothek für numerische Integration.
Diese bietet verschiedene Algorithmen an welche ein Integral der Form

\begin{equation*}
    I = \int_{a}^{b} f(x) w(x) \,dx
\end{equation*}
lösen, wobei $w(x)$ eine Gewichtungsfunktion ist. Um die Genauigkeit festzulegen müssen die Grenzen $epsabs$ und $epsrel$ für die absoluten und relativen Fehler angegeben werden.
Die Genauigkeit ist über die Ungleichung 
\begin{equation*}
    |RESULT - I| \leq \max{(epsabs, epsrel |I|)}
\end{equation*}
definiert, wobei $RESULT$ die Approximation des Algorithmus darstellt. Die Algorithmen liefern das erste Ergebnis, dessen absoluter Fehler kleiner als $epsabs$ bzw. dessen relativer Fehler kleiner als $epsrel$ ist. (Vgl. GSL-Handbuch Kapitel 17.1 \cite{gsl})


%The algorithms in QUADPACK use a naming convention based on the following letters:

%The algorithms are built on pairs of quadrature rules, a higher order rule and a lower order rule. The higher order rule is used to compute the best approximation to an integral over a small range. The difference between the results of the higher order rule and the lower order rule gives an estimate of the error in the approximation.

In dieser Arbeit wird das sogenannte \textit{QUAGS}-Integrationsverfahren verwendet. %Das Kürzel \textit{QUAGS} steht für \textbf{Q}uadrature routine
Dieses adaptive Verfahren kann Integrale mit Singularitäten berechnen. Bei adaptiven Verfahren wird das zu integrierende Intervall in kleinere Teilintervalle aufgeteilt, die entsprechend ihres Fehlerterms ausgewählt werden.
Bei dem \textit{QUAGS}-Verfahren werden diese Teilintervalle auf die Singularität konzentriert. (siehe GSL-Handbuch Kapitel 17.4 \cite{gsl})
Hierbei wird die Gauss-Kronrod 21-Punkt Integrationsregel verwendet.\\

Das Verfahren kann nicht direkt genutzt werden, um die benötigten Integrationen aus \cite*{gasperini:hal-03209144} zu berechnen, da 
der \textit{QUAGS}-Algorithmus zum einen nur für eindimensionale Integrale und nur für den reellen Zahlenraum definiert ist.

Um dies zu ermöglichen, sind zwei Anpassungen nötig:
\begin{enumerate}
    \item Das Verschachteln von zwei \textit{QUAGS}-Aufrufen
    \item Das Auftrennen in zwei getrennte Aufrufe, jeweils für den Real- und Imaginär-teil der Integranden
\end{enumerate}

Die Implementierung für den Realteil ist in \ref{integration_2d} zu sehen.

\begin{figure}
    \lstinputlisting[language=C++,style=cpp]{gsl_integrator_2d.cpp}
    \caption{Berechnung des komplexen Doppel-Integrals mit GSL (Realteil)}
    \label{integration_2d}
\end{figure}


\subsection{Armadillo}

Armadillo ist eine C++-Bibliothek von \citeauthor{armadillo}, welche Datenstrukturen und Algorithmen der linearen Algebra bereitstellt.
Die Funktionalität und Syntax ist an die von Matlab angelehnt mit dem Ziel, die Umsetzung von \textit{Researchcode} in Produktivcode möglichst einfach zu gestalten \cite{armadillo}.


\begin{center}
    \begin{lstlisting}[language=C++,style=cpp]
        arma::mat A = {{0, 0} , {1, 0}, {0, 1}};
        //use matrix 
        // ...
    \end{lstlisting}
    \begin{lstlisting}[language=C++,style=cpp]
        gsl_matrix * m = gsl_matrix_alloc (3, 2);
        gsl_matrix_set(m, 0, 0) = 0;
        gsl_matrix_set(m, 0, 1) = 0;
        gsl_matrix_set(m, 1, 0) = 1;
        gsl_matrix_set(m, 1, 1) = 0;
        gsl_matrix_set(m, 2, 0) = 0;
        gsl_matrix_set(m, 2, 1) = 1;
        //use matrix 
        // ...
        //free
        gsl_matrix_free (m);
    \end{lstlisting}
    \captionof{figure}{Vergleich von Matrizen in Armadillo und GSL}
    \label{gslarma}
\end{center}

Die GSL bietet zwar auch ein Framework für lineare Algebra, allerdings ist die API von Matlab deutlich moderner und einfacher zu verwenden. (siehe Abbildung \ref{gslarma})


\subsection{Intel Threading Building Blocks}


Die Intel\textsuperscript{\textcopyright} oneAPI Threading Building Blocks (oneTBB) ist eine Template-basierte Bibliothek zur effizienten Parallelisierung von Anwendungen. 
Mithilfe von oneTBB ist es möglich mit wenigen Schritten einen Algorithmus auf mehreren Threads auszuführen.

oneTBB bietet für diverse Parallelisierungsprobleme  Algorithmen und Datenstrukturen an, von einfachen Schleifen, bis hin zu Graph-Based-Parallel Computing.
In dieser Arbeit wurden lediglich die einfacheren Konzepte von parallelen Schleifen genutzt. Für diese Anwendungsfälle stellt oneTBB unter anderem die Funktionen \texttt{parallel\_for} und \texttt{parallel\_reduce}
zur Verfügung. Diese arbeiten auf sogenannten \textit{Ranges}, welche eine Abstraktion der zu bearbeitenden Daten sind.

Ranges können die zu verarbeitende Datenmenge in kleinere Bereiche aufteilen. Diese Teilbereiche werden von oneTBB dann parallelisiert. Die Daten innerhalb einer Range werden sequenziell verarbeitet. 
Wie groß diese Teilbereiche werden und welcher Art die Aufteilung ist, kann mithilfe von Parametern gesteuert werden. In dieser Arbeit wird dies mit der sogenannten Blocked-Ranges (\texttt{blocked\_range}) realisiert, welche die Datenmenge in kontinuierliche Blöcke aufteilt. Die Größe der jeweiligen Blöcke wird mit der sogenannten \textit{Grainsize} gesteuert.
oneTBB bietet verschiedene Arten von Blocked-Ranges für bis zu drei Dimensionen. Die Grainsize muss dem zu lösenden Problem entsprechend groß gewählt werden.

\begin{center}
    \lstinputlisting[language=C++,style=cpp]{tbb_example.cpp}
    \captionof{figure}{Minimalbeispiel von \texttt{paralell\_reduce}}
\end{center}

In dieser Arbeit werden ausschließlich Parallelisierungen mithilfe von \linebreak \texttt{parallel\_recude} bzw. \texttt{parallel\_deterministic\_reduce} umgesetzt.
Diese bieten die Möglichkeit für jedes Datum eine Transformation durchzuführen und anschließend die transformierten Daten zu vereinigen. 
So wird beispielsweise in der Implementierung (siehe Abschnitt \ref{gauss_laguerre_section}) des Gauss-Laguerrre-Verfahrens ein zu integrierender Pfad parallel an den einzelnen Gauss-Laguerre-Knotenpunkten ausgewertet und entsprechend gewichtet.
Die so berechneten Teilwerte werden nun noch addiert und ergeben so das komplexe (Teil-)Integral des Pfades. 

\subsection{Pybind11}

Das Python-Modul wird mithilfe der Bibliothek \textit{pybind11} umgesetzt.
Pybind11 ist eine sogenannte Header-only Bibliothek mit dem Ziel eine leichtgewichtige Alternative zu bestehenden Bibliotheken zur Erstellung  von
Python-bindings für C++-Bibliotheken anzubieten.
Pybind11\cite{pybind} ist ein Opensource-Projekt und wird unter einer BSD-artigen Lizenz veröffentlicht. 

Folgendes Beispiel\footnote{Beispielcode stammt von \url{https://pybind11.readthedocs.io/en/latest/basics.html} aus der pybind-Dokumenation\cite{pybind}.} stellt die C++-Funktion \textit{add} als Python-Modul bereit:
\begin{center}
\lstinputlisting[language=C++,style=cpp]{pybind11_example.cpp}
\end{center}
Dieses kann in einer Pythonumgebung wie folgt verwendet werden:

\begin{center}
\begin{lstlisting}[language=Python]
import example;
example.add(1, 2);
\end{lstlisting}
\end{center}



\subsection{Matlab Mex-Funktion}

Um eine C++-Funktion in Matlab zur Verfügung zu stellen, gibt es mehrere Ansätze.
Zum einen kann mithilfe von Matlab C++-Code kompiliert und anschließend genutzt werden. 
Die für den Endnutzer einfachere Variante ist das Bereitstellen von sogenannten Mex-Funktionen.

Um eine Mex-Funktion zu implementieren, müssen die Header-Dateien \texttt{mex.hpp} und \texttt{mexAdapter.hpp} inkludiert werden
und eine Funktion mit dem Namen \textit{MexFunction} implementiert werden. 

In Abbildung \ref{mexfunction} ist eine Beispiel-Implementierung zu sehen.
\begin{center}
    \lstinputlisting[language=C++,style=cpp]{mex_function.cpp}
    \captionof{figure}{Eine einfache Mex-Funktion ohne Logik}
    \label{mexfunction}
\end{center}

Nachdem diese kompiliert wurde, lässt sie sich aus Matlab heraus aufrufen.


\subsection{Sonstige}

Als Testframework für automatisierte Unit-Tests wird die Bilbiothek \textit{catch2} verwendet.
Zum Durchführen der automatisierten Benchmarks wird auf die Bibliothek \textit{Benchmark} von Google zurückgegriffen.


%\subsection{Ungenutzte alternativen}


%\begin{itemize}
%    \item Boost numeric
%    \item OpenCL
%    \item OpenMP
%    \item CUDA
%\end{itemize}


\section{Ausgewählte Codestellen}

In diesem Abschnitt werden Details der Implementierung näher beleuchtet. Es werden ausgewählte Codestellen vorgestellt, die wesentliche Funktionen implementieren.

\subsection{Gauss-Laguerre-Verfahren}\label{gauss_laguerre_section}

Die Berechnung der Pfadintegrale wird mithilfe des Gauss-Laguerre-Verfahrens realisiert.
Da die Auswertung der Pfadfunktion an den Gauss-Laguerre-Knoten unabhängig voneinander ist,
 wird diese Berechnung mithilfe der Funktion \linebreak \texttt{parallel\_determinictic\_reduce} der oneTBB API parallisiert.
Diese Funktion verhält sich ähnlich wie \texttt{parallel\_reduce}, hat jedoch ein anderes Verhalten hinsichtlich des sogenannten \textit{splittings} der Ranges. 
Die \textit{Grainsize} ist auf 100 Elemente festgelegt, kleinere Blockgrößen haben in Performanztests keine signifikante Beschleunigung ermöglicht und größere haben die Laufzeit negativ beeinflusst.

\begin{center}
    \lstinputlisting[language=C++,style=cpp]{gauss_laguerre.cpp}
    \captionof{figure}{Implementierung der Gauss-Laguerre-Quadratur}
    \label{gauss_laguerre_impl}
\end{center}

\subsection{Gewichtung der Pfade}

In der Datei \textit{path\_utils.cpp} werden Funktionen zur Berechnung der gewichteten Pfade bereitgestellt.
Diese werden dann, wie im Abschnitt \ref{gauss_laguerre_section} beschrieben, verwendet um die \textit{zulässigen} Pfade zu berechnen.
Es werden drei verschiedene Gewichtungen vorgenommen:
\begin{itemize}
    \item Für den eindimenisionalen Fall
    \item Für den $\Lambda$-Term im zweidimensionalen Fall
    \item Für die Pfade im zweidimensionalen Fall
\end{itemize}

Die Implementierung ist in Abbilung \ref{path_utils} zu sehen.

\begin{center}
    \lstinputlisting[language=C++,style=cpp,mathescape=true]{path_utils.cpp}
    \captionof{figure}{Funktionen zur Berechnung gewichteter Pfade}
    \label{path_utils}
\end{center}

\subsection{1D-Integration}

Die 1D-Integration ist als sogenanntes \textit{Functor-Objekt} implementiert. 

\begin{center}
    \lstinputlisting[language=C++,style=cpp,mathescape=true]{1d_integral.hpp}
    \captionof{figure}{}
\end{center}

\subsubsection*{Berechung der Singularität}

In Kapitel 5.1 \cite[12]{gasperini:hal-03209144} (Formel 16) wird die Formel für den eindimenisionalen Fall, im Fall einer Singularität im Interval $[a_1, b_1]$, wie folgt beschrieben:

\begin{equation}
    I(k,y,a,b,) = I(k,y,a,a_1) + I(k,y,a_1, b_1) + I(k,y,b_1,b)
\end{equation}

Die partiellen Integrale in den Intervallen $[a,a_1]$ und  $[b_1,b_1]$ können mithilfe des \textit{steepest-descent}-Verfahrens berechnet werden.
Lediglich das verbleibende Interval muss mit einem klassischen Integrationsverfahren berechnet werden.
Dieses Verfahren muss also fähig sein, Singularitäten in einem Integral zu berechnen. Dies ist nicht bei allen Integrationsverfahren gegeben (z.B. dem sogenannten QAG-Verfahren aus der GSL).

Die Implementierung des Integrals auf Pfaden mit Singularität ist in folgender Abbildung enthalten:
\begin{center}
    \lstinputlisting[language=C++,style=cpp,mathescape=true]{1d_integration_singularity.cpp}
    \captionof{figure}{Implementierung des 1D-Falls (Singularität)}
\end{center}

Dabei werden die Intervalle ohne Singularität mit dem Gauss-Laguerre-Verfahren (siehe Abbildung \ref{gauss_laguerre_impl}) berechnet und die verbleibende partielle Integration,
welches die Form
\begin{equation*}
    I(k,y,a,b) := \int_{a}^{b}  \frac{e^ikg(x)}{\sqrt{P(x)}} \,dx 
\end{equation*}
hat, mithilfe eines Aufruf des GSL-Integrators berechnet (Analog zum 2D Fall, siehe Abbildung \ref{integration_2d})



\subsection{2D-Integration}\label{2dint}

Ebenso wie die 1D-Integration wird die 2D-Integration als sogenanntes \textit{Functor-Objekt} implementiert (siehe Abbildung \ref{2d_integral_functor}). 
Im Konstruktor werden die invarianten Parameter übergeben und in dem Aufrufoperator werden die Dreiecksparameter, der Blickpunkt $r$ und der Richtungsvektor $\theta$ übergeben.

In diesem Abschnitt wird primär auf die Berechnung einer einzelnen Schicht $n$ eingangen. Die Anzahl der zu berechnenden Schichten wird aus der Konfiguration (siehe Abbildung \ref{configuration}) abgeleitet. 
Die Menge der Schichten wird mithilfe der oneTBB Funktion \texttt{parallel\_reduce} parallelisiert.

\begin{center}
    \lstinputlisting[language=C++,style=cpp,mathescape=true]{integral_2d_reduce.cpp}
    \captionof{figure}{Parallelisierung des 2D-Integrals}
    \label{2d_integral_parallel}
\end{center}

Dabei hat sich gezeigt, dass eine Blockgröße von 1 zu den besten Ergebnissen führt.
Die zu berechnende Schicht kann nun in zwei Fälle unterteilt werden: Mit Singularität und ohne.

\subsubsection*{Berechnung von $\Lambda_a$}

Die $\Lambda_a$-Terme werden mithilfe des eindimenisionalen Verfahrens berechnet.
Dabei wird dieser mit angepassten Funktionen für die Pfadgewichtung sowie angepasstem Integranden für die klassische Integration ausgeführt.

\begin{center}
    \lstinputlisting[language=C++,style=cpp]{integral_2d_partial.cpp}
\end{center}

Im Quellcode werden Aufrufe dieser Instanz mit \textit{partial\_integral} ausgeführt.
In den folgenden Abschnitten wird auf die Behandlung der Fälle ohne und mit Singularitäten eingegangen.
Die gezeigten Codestellen zeigen lediglich einen Ausschnitt. Im vollständigen Code ist dies in der Datei \textit{integral.cpp} in einer parallelisierten Schleife
eingebunden. 

\subsubsection*{Fall 1: Keine Singularität in Schich $n$}

Dabei ist der Fall ohne Singularität der trivialere Fall:

\begin{center}
    \lstinputlisting[language=C++,style=cpp,mathescape=true]{integral_2d_trivial.cpp}
    \captionof{figure}{Schicht $n$ ohne Singularität}
    \label{2d_integral_trivial}
\end{center}


\subsubsection*{Fall 2: Singularität in Schicht $n$}

Diesem Fall gehen die Berechnungen des ersten Falles vorraus (angedeutet in Abbildung \ref{2d_integral_sing}).
In Schicht $n$ liegt eine Singularität vor. Für diese werden die \textit{Splitting-points} berechnet. Mithilfe dieser wird der Teilpfad für das klassische Integrationsverfahren bestimmt.
(Berechnung des Integrals in Zeile 32 Abbildung \ref{2d_integral_sing}).
Die Implementierung dieser Funktion ergibt sich nicht komplett aus der Arbeit \cite{gasperini:hal-03209144}, denn in der zugrundeliegenden Matlab-Implementierung wird ersichtlich, dass für den Fall der Singularität 
eine weitere Sache berücksichtigt werden muss: eine von den Autoren der Implementierung genannte \textit{Integrationsbox}, welche eine Ungenauigkeit bei der Berücksichtigung der Singularität darstellt.
Diese lässt sich wie folgt erklären: durch das Aufteilen der zu integrierenden Dreiecksoberfäche in Schichten wird die Position der Singularität, bedingt durch die \glqq Höhe\grqq{} der Schicht, gegebenenfalls zu stark gewichtet.
Dies wird mit einer partiellen Integration an dieser Stelle über die vertikale Dimension ausgeglichen (Zeilen 26-29).

\begin{center}
    \lstinputlisting[language=C++,style=cpp,mathescape=true]{integral_2d_singularity.cpp}
    \captionof{figure}{Schicht $n$ mit Singularität}
    \label{2d_integral_sing}
\end{center}
